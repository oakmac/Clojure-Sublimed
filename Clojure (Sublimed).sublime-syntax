%YAML 1.2
---
# https://www.sublimetext.com/docs/syntax.html
name: Clojure (Sublimed)
file_extensions: [clj, cljs, cljc, cljx, boot, bb, edn]
scope: source.clojure
variables:
  wsb:          '(?<=^|[\s,()\[\]{}~''`"^@]|#_)'
  wse:           '(?=$|[\s,()\[\]{}";])'
  nwse:              '[^\s,()\[\]{}";]'
  sym_head:     '[\p{Alpha}*!_?$%&=<>]'
  sym_head_lax: '[\p{Alpha}*!_?$%&=<>''\-+.#:]'
  sym_body:     '[\p{Alpha}*!_?$%&=<>''\-+.#:0-9]'
  ns_symbol:    '(?:[\-+.]|[\-+.]{{sym_head_lax}}{{sym_body}}*|{{sym_head}}{{sym_body}}*)'
  symbol:       '(?:/|{{ns_symbol}})'
  kw_head:      '[\p{Alpha}*!_?$%&=<>''\-+.#0-9]'
  kw_body:      '[\p{Alpha}*!_?$%&=<>''\-+.#0-9:]'
  keyword:      '{{kw_head}}{{kw_body}}*'
  regexp_name:  '[a-zA-Z][a-zA-Z0-9]*'
contexts:
  main:
    - include: comma
    - include: line_comment
    - include: reader_comment
    - include: metadata
    - include: quote
    - include: syntax_quote
    - include: syntax_unquote
    - include: deref
    - match: (?=\S)
      push: forms

  forms:
    - include: comma
    - include: line_comment
    - include: reader_comment
    - include: metadata
    - include: quote
    - include: syntax_quote
    - include: syntax_unquote
    - include: deref
    - include: character
    - include: string
    - include: regexp
    - include: constant
    - include: keyword
    - include: integer
    - include: float
    - include: ratio
    - include: symbol_unused
    - include: symbol
    - include: var
    - include: list
    - include: anonymous_fn
    - include: reader_conditional
    - include: vector
    - include: map
    - include: set
    - include: tag
    - include: stray_bracket

  comma:
    - match: ','
      scope: punctuation.definition.comma.clojure

  line_comment:
    - match: '(;+).*$'
      scope: comment.line.clojure
      captures:
        1: punctuation.definition.comment.line.clojure

  reader_comment:
    - match: '#_'
      scope: punctuation.definition.comment.reader.clojure
      push: 
      - meta_scope: comment.reader.clojure
      - include: forms

  metadata:
    - match: '\^'
      scope: punctuation.definition.metadata.clojure
      push: 
      - meta_scope: meta.metadata.clojure
      - include: forms

  quote:
    - match: ''''
      scope: keyword.operator.quote.clojure
      push: 
      - meta_scope: meta.quoted.clojure
      - include: forms

  syntax_quote:
    - match: '`'
      scope: keyword.operator.quote.syntax.clojure
      push: 
      - meta_scope: meta.quoted.syntax.clojure
      - include: forms

  syntax_unquote:
    - match: '~@?'
      scope: keyword.operator.unquote.clojure
      push: 
      - meta_scope: meta.unquoted.clojure
      - include: forms

  deref:
    - match: '@'
      scope: keyword.operator.deref.clojure
      push: 
      - meta_scope: meta.deref.clojure
      - include: forms

  character:
    - match: '{{wsb}}((\\)(u\h{4}|o[0-3]?[0-7]{1,2}|newline|tab|space|backspace|formfeed|return|[^\s]){{wse}}|((\\){{nwse}}*))'
      scope: constant.character.clojure
      captures:
        2: punctuation.definition.character.begin.clojure
        4: invalid.illegal.character.clojure
        5: punctuation.definition.character.begin.clojure
      pop:   1

  string:
    - match: '{{wsb}}"'
      scope: punctuation.definition.string.begin.clojure
      push:
      - meta_scope: string.quoted.double.clojure
      - match: '(\\)(u\h{4}|b|t|n|f|r|"|''|\\|[0-3]?[0-7]{1,2})|((\\).)'
        scope: constant.character.escape.clojure
        captures:
          1: punctuation.definition.character.escape.begin.clojure 
          3: invalid.illegal.escape.string.clojure
          4: punctuation.definition.character.escape.begin.clojure
      - match: '"'
        scope: punctuation.definition.string.end.clojure
        pop:   2

  regexp_quote:
    - match: '\\Q'
      scope: punctuation.section.quotation.begin.clojure
      push:
        - meta_content_scope: constant.character.escape.clojure
        - match: '\\"'
        - match: '(?=")'
          pop:   1
        - match: '\\E'
          scope: punctuation.section.quotation.end.clojure
          pop:   1

  regexp_shared:
    - match: '(\\)(\\|0[0-3]?[0-7]{1,2}|x\h{2}|u\h{4}|x\{1?\h{1,5}\}|\N\{[a-zA-Z0-9\- ]+\}|[tnrfae]|c[A-Z]|[dDhHsSvVwW]|p\{[a-zA-Z]+\}|b\{g\}|[bBAGZz]|[RX]|[0-9]+|k<{{regexp_name}}>|[^a-zA-Z0-9])|((\\).)'
      scope: constant.character.escape.clojure
      captures:
          1: punctuation.definition.character.escape.begin.clojure 
          3: invalid.illegal.escape.regexp.clojure
          4: punctuation.definition.character.escape.begin.clojure
    - match: '"'
      scope: punctuation.definition.string.end.clojure
      pop:   2
    - match: '(\[)(\^)?(-)?'
      captures:
        1: punctuation.section.brackets.begin.clojure
        2: keyword.operator.negation.regexp.clojure
      push:
      - match: '(?=")'
        pop:   1
      - match: '\]'
        scope: punctuation.section.brackets.end.clojure
        pop:   1
      - match: '-(?!\])'
        scope: keyword.operator.range.regexp.clojure
      - match: '&&'
        scope: keyword.operator.intersection.regexp.clojure
      - include: regexp_shared
    - match: '(?:[?*+]|\{\d+(?:,(?:\d+)?)?\})[?+]?'
      scope: keyword.operator.quantifier.regexp.clojure

  regexp_group:
    - include: regexp_quote
    - include: regexp_shared
    - match: '\|'
      scope: keyword.operator.union.regexp.clojure
    - match: '(\()(\?(<{{regexp_name}}>|:|=|!|<=|<!|>|[idmsux]*(-[idmsux]+)?:|[idmsuxU]*(-[idmsuxU]+)?(?!:)))?'
      captures:
        1: punctuation.section.parens.begin.clojure
        2: keyword.operator.special.regexp.clojure
      push:
      - match: '(?=")'
        pop:   1
      - match: '\)'
        scope: punctuation.section.parens.end.clojure
        pop:   1
      - include: regexp_group
    - match: '[\)]'
      scope: invalid.illegal.stray-bracket-end

  regexp:
    - match: '{{wsb}}#"'
      scope: punctuation.definition.string.begin.clojure
      push:
      - meta_scope: string.regexp.clojure
      - include: regexp_group

  constant:
    - match: '{{wsb}}(nil|true|false){{wse}}'
      scope: constant.language.clojure
      pop: 1

  keyword:
    - match: '{{wsb}}(::?)(?:{{keyword}}|({{keyword}})(/){{keyword}}){{wse}}'
      scope: constant.other.keyword.clojure
      captures:
        1: punctuation.definition.keyword.begin.clojure
        2: meta.namespace.keyword.clojure
        3: punctuation.definition.namespace.clojure
      pop:   1

  integer:
    - match: '{{wsb}}[+-]?(?:0x0|0x[1-9a-fA-F][0-9a-fA-F]*|0|[1-9][0-9]*)(N)?{{wse}}'
      scope: constant.numeric.integer.clojure
      captures:
        1: punctuation.definition.integer.precision.clojure
      pop:   1

  float:
    - match: '{{wsb}}[+-]?(?:0|[1-9][0-9]*)(?:(M)|\.[0-9]*(M)?|[eE][+-]?[0-9]+(M)?|\.[0-9]*[eE][+-]?[0-9]+(M)?){{wse}}'
      scope: constant.numeric.float.clojure
      captures:
        1: punctuation.definition.float.precision.clojure
        2: punctuation.definition.float.precision.clojure
        3: punctuation.definition.float.precision.clojure
        4: punctuation.definition.float.precision.clojure
      pop:   1
    - match: '{{wsb}}(##Inf|##-Inf|##NaN){{wse}}'
      scope: constant.numeric.float.clojure
      pop:   1

  ratio:
    - match: '{{wsb}}[+-]?(0|[1-9][0-9]*)/[1-9][0-9]*{{wse}}'
      scope: constant.numeric.ratio.clojure
      pop:   1

  symbol_def:
    - match: '{{wsb}}(?:(?=def){{symbol}}|({{ns_symbol}})(/)(?=def){{symbol}}){{wse}}'
      scope: source.symbol.def.clojure
      captures:
        1: meta.namespace.symbol.clojure
        2: punctuation.definition.namespace.clojure
      pop: 1
      push: list_second

  symbol_name:
    - match: '{{wsb}}(?:{{symbol}}|({{ns_symbol}})(/){{symbol}}){{wse}}'
      scope: source.symbol.clojure entity.name.clojure
      captures:
        1: meta.namespace.symbol.clojure
        2: punctuation.definition.namespace.clojure
      pop: 1
      push: list_rest

  symbol_unused:
    - match: '{{wsb}}(?:(?=_){{symbol}}|({{ns_symbol}})(/)(?=_){{symbol}}){{wse}}'
      scope: source.symbol.unused.clojure
      captures:
        1: meta.namespace.symbol.clojure
        2: punctuation.definition.namespace.clojure
      pop:   1

  symbol:
    - match: '{{wsb}}(?:{{symbol}}|({{ns_symbol}})(/){{symbol}}){{wse}}'
      scope: source.symbol.clojure
      captures:
        1: meta.namespace.symbol.clojure
        2: punctuation.definition.namespace.clojure
      pop:   1

  var:
    - match: '#'''
      scope: punctuation.definition.var.clojure
      push: 
      - meta_scope: meta.var.clojure
      - include: symbol
      - include: comma
      - include: fail

  tag:
    - match: '{{wsb}}(#inst\s*"\d\d\d\d(?:-[01]\d(?:-[0123]\d(?:T[012]\d(?::[012345]\d(?::[0123456]\d(?:[.]\d{1,9})?)?)?)?)?)?(?:Z|[-+][012]\d:[012345]\d)?"|(#inst\s*"[^"]*")){{wse}}'
      scope: constant.other.instant.clojure
      captures:
        2: invalid.illegal.instant.clojure
      pop:   1
    - match: '{{wsb}}(#uuid\s*"\h{8}-\h{4}-\h{4}-\h{4}-\h{12}"|(#uuid\s*"[^"]*")){{wse}}'
      scope: constant.other.uuid.clojure
      captures:
        2: invalid.illegal.uuid.clojure
      pop:   1
    - match: '{{wsb}}#(?![_#{])(?:{{symbol}}|{{ns_symbol}}(/){{symbol}}){{wse}}'
      scope: storage.type.tag.clojure
      pop:   1

  list:
    - match: '(?=\()'
      branch_point: open_parens
      branch:
        - list_paren
        - form_comment_paren

  list_paren:
    - match: '\('
      scope: punctuation.section.parens.begin.clojure
      set: list_first

  list_first:
    - meta_scope: meta.parens.clojure
    - match: \)
      scope: punctuation.section.parens.end.clojure
      pop:   2
    - include: comma
    - include: line_comment
    - include: reader_comment
    - include: metadata
    - match: 'comment'
      fail: open_parens
    - include: symbol_def
    - match: '(?=\S)'
      set: list_rest

  list_second:
    - meta_scope: meta.parens.clojure
    - match: \)
      scope: punctuation.section.parens.end.clojure
      pop:   2
    - include: comma
    - include: line_comment
    - include: reader_comment
    - include: metadata
    - include: symbol_name
    - match: '(?=\S)'
      set: list_rest

  list_rest:
    - meta_scope: meta.parens.clojure
    - match: \)
      scope: punctuation.section.parens.end.clojure
      pop:   2
    - include: main

  form_comment_paren:
    - match: '\('
      scope: punctuation.section.parens.begin.clojure
      set: form_comment_first

  form_comment_first:
    - meta_scope: comment.form.clojure
    - include: comma
    - include: line_comment
    - include: reader_comment
    - include: metadata
    - match: 'comment'
      set: form_comment_rest
    - match: \)
      fail: open_parens
    - match: '(?=\S)'
      fail: open_parens

  form_comment_rest:
    - meta_scope: comment.form.clojure
    - match: \)
      scope: punctuation.section.parens.end.clojure
      pop:   2
    - include: main

  anonymous_fn:
    - match: '(#)(\()'
      captures:
        1: punctuation.definition.anon_fn.clojure
      scope: punctuation.section.parens.begin.clojure
      push:
      - meta_scope: meta.parens.clojure meta.function.anon.clojure
      - match: \)
        scope: punctuation.section.parens.end.clojure
        pop:   2
      - include: main

  reader_conditional:
    - match: '#\?@?'
      scope: punctuation.definition.reader_conditional.clojure punctuation.section.parens.begin.clojure
      push:
      - meta_scope: meta.reader_conditional.clojure meta.parens.clojure
      - include: comma
      - match: '\('
        scope: punctuation.section.parens.begin.clojure
        push:
          - match: '\)'
            scope: punctuation.section.parens.end.clojure
            pop: 3
          - include: main
      - include: fail

  vector:
    - match: \[
      scope: punctuation.section.brackets.begin.clojure
      push:
      - meta_scope: meta.brackets.clojure
      - match: \]
        scope: punctuation.section.brackets.end.clojure
        pop:   2
      - include: main

  map:
    - match: '\{'
      scope: punctuation.section.braces.begin.clojure
      push:
      - meta_scope: meta.braces.clojure
      - match: \}
        scope: punctuation.section.braces.end.clojure
        pop:   2
      - include: main

  set:
    - match: '#\{'
      scope: punctuation.section.braces.begin.clojure
      push:
      - meta_scope: meta.braces.clojure
      - match: \}
        scope: punctuation.section.braces.end.clojure
        pop:   2
      - include: main

  stray_bracket:
    - match: '[\]\)\}]'
      scope: invalid.illegal.stray-bracket-end
      pop:   1

  fail:
      - match: '(?=\S)'
        pop: 1
